/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   malloc_comb.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nidionis <nidionis@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 01:34:57 by nidionis          #+#    #+#             */
/*   Updated: 2025/02/03 01:35:06 by nidionis         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <push_swap.h>

/*
int	*malloc_instr_steps_itm(t_data *data)
{
	int	*instr_steps_itm;

	instr_steps_itm = ft_calloc(4, sizeof(int));
	if (!instr_steps_itm)
		return (NULL);
	instr_steps_itm[NB_INSTR] = SIZE_MAX;
	instr_steps_itm[INSTR] = NO_INSTR;
	if (!data)
	{
		instr_steps_itm[NB_INSTR] = 0;
		return (instr_steps_itm);
	}
	instr_steps_itm[NB_INSTR] = data->best_inst_step[NB_INSTR];
	instr_steps_itm[INSTR] = data->best_inst_step[INSTR];
	return (instr_steps_itm);
}

int	*malloc_best_insert(t_data *data)
{
	int	*best_comb;

	best_comb = malloc(4 * sizeof(int));
	if (!best_comb)
		return (FALSE);
	best_comb[FIRST_INSTR] = data->best_comb[FIRST_INSTR];
	best_comb[NB_FIRST_INSTR] = data->best_comb[NB_FIRST_INSTR];
	best_comb[SECOND_INSTR] = data->best_comb[SECOND_INSTR];
	best_comb[NB_SECOND_INSTR] = data->best_comb[NB_SECOND_INSTR];
	return (best_comb);
}
	*/