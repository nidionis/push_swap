diff --git a/Makefile b/Makefile
index db65260..58e5b6a 100644
--- a/Makefile
+++ b/Makefile
@@ -11,6 +11,7 @@
 # **************************************************************************** #
 
 NAME = push_swap
+CHECKER = checker
 
 LIBRARIES = ft
 LIB_NAMES = $(addprefix lib, $(LIBRARIES))
@@ -29,20 +30,32 @@ LIBS = $(addprefix $(LIB_DIR)/,$(LIB_NAMES))
 SRC_DIR = ./src
 SRCS = $(shell find $(SRC_DIR) -type f -name "*.c")
 MAIN = main.c
+CHECKER_SRCS = checker.c
 
 OBJ_DIR = ./obj
-OBJS = $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(SRCS)) $(OBJ_DIR)/main.o
+SRC_OBJS = $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(SRCS))
+MAIN_OBJ = $(OBJ_DIR)/main.o
+CHECKER_OBJ = $(OBJ_DIR)/checker.o
+
+# Objets pour les exécutables
+PUSH_SWAP_OBJS = $(SRC_OBJS) $(MAIN_OBJ)
+CHECKER_OBJS = $(SRC_OBJS) $(CHECKER_OBJ)
 
 INCLUDES = $(addprefix -I,$(INCLUDE_DIRS))
 
-all: make_libs $(NAME)
+all: $(NAME)
+
+checker: $(CHECKER)
 
-$(NAME): $(OBJS)
-	$(CC) $(CFLAGS) $(INCLUDES) $(LDFLAGS) $(OBJS) -o $@ $(LDLIBS)
+$(NAME): make_libs $(PUSH_SWAP_OBJS)
+	$(CC) $(CFLAGS) $(INCLUDES) $(LDFLAGS) $(PUSH_SWAP_OBJS) -o $@ $(LDLIBS)
+
+$(CHECKER): make_libs $(CHECKER_OBJS)
+	$(CC) $(CFLAGS) $(INCLUDES) $(LDFLAGS) $(CHECKER_OBJS) -o $@ $(LDLIBS)
 
 make_libs:
 	@for lib in $(LIB_NAMES); do \
-		$(MAKE) -C $(LIB_DIR)/$$lib $(MAKECMDGOALS); \
+		$(MAKE) -C $(LIB_DIR)/$$lib; \
 	done
 
 $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
@@ -52,6 +65,9 @@ $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
 $(OBJ_DIR)/main.o: main.c | $(OBJ_DIR)
 	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@
 
+$(OBJ_DIR)/checker.o: checker.c | $(OBJ_DIR)
+	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@
+
 $(OBJ_DIR):
 	mkdir -p $(OBJ_DIR)
 
@@ -65,10 +81,12 @@ fclean: clean
 	@for lib in $(LIB_NAMES); do \
 		$(MAKE) -C $(LIB_DIR)/$$lib fclean; \
 	done
-	rm -f $(NAME)
+	rm -f $(NAME) $(CHECKER)
 
 re: fclean all
 
+
+
 install_visualizer:
 	git clone https://github.com/o-reo/push_swap_visualizer.git
 	cd push_swap_visualizer
@@ -82,4 +100,4 @@ visual:
 	cd push_swap_visualizer/build && ./bin/visualizer && cd -
 	cd -
 
-.PHONY: all clean fclean re make_libs
+.PHONY: all clean fclean re make_libs checker
diff --git a/src/tools/apply_best_comb.c b/src/tools/apply_best_comb.c
index 83a7d7d..706fd3f 100644
--- a/src/tools/apply_best_comb.c
+++ b/src/tools/apply_best_comb.c
@@ -21,7 +21,7 @@
  * @param verbose Mode verbeux (1) ou silencieux (0)
  * @return int Status de l'opération
  */
-int apply_set_and(int (*f_do)(t_data *d, int instr), t_data *data, t_instr_step *instr_step, int verbose)
+int ps_apply_set_and(int (*f_do)(t_data *d, int instr), t_data *data, t_instr_step *instr_step, int verbose)
 {
     int count;
     int status;
@@ -50,18 +50,18 @@ int apply_set_and(int (*f_do)(t_data *d, int instr), t_data *data, t_instr_step
  * @param verbose Mode verbeux (1) ou silencieux (0)
  * @return int Status de l'opération
  */
-static int apply_best_comb_recursive(int (*f_do)(t_data *d, int instr), t_data *data, t_list *best_comb, int verbose)
+static int ps_apply_best_comb_recursive(int (*f_do)(t_data *d, int instr), t_data *data, t_list *best_comb, int verbose)
 {
     int status;
     
     if (!best_comb)
         return (TRUE);
         
-    status = apply_set_and(f_do, data, best_comb->content, verbose);
+    status = ps_apply_set_and(f_do, data, best_comb->content, verbose);
     if (status != TRUE && status != 0)
         return (status);
         
-    return (apply_best_comb_recursive(f_do, data, best_comb->next, verbose));
+    return (ps_apply_best_comb_recursive(f_do, data, best_comb->next, verbose));
 }
 
 /**
@@ -73,7 +73,7 @@ static int apply_best_comb_recursive(int (*f_do)(t_data *d, int instr), t_data *
  * @param verbose Mode verbeux (1) ou silencieux (0)
  * @return int Status de l'opération
  */
-int apply_best_comb_and(int (*f_do)(t_data *d, int instr), t_data *data, t_list *best_comb, int verbose)
+int ps_apply_best_comb_and(int (*f_do)(t_data *d, int instr), t_data *data, t_list *best_comb, int verbose)
 {
-    return apply_best_comb_recursive(f_do, data, best_comb, verbose);
+    return ps_apply_best_comb_recursive(f_do, data, best_comb, verbose);
 }
\ No newline at end of file
diff --git a/src/tools/apply_instr.c b/src/tools/apply_instr.c
index a0fcaf7..17b4b8a 100644
--- a/src/tools/apply_instr.c
+++ b/src/tools/apply_instr.c
@@ -89,7 +89,7 @@ void	execute_command(t_lnk **lst_a, t_lnk **lst_b, int instr, t_instr_map instr_
 	//ft_errmsg("[execute_command] Invalid instruction");
 }
 
-int	is_rotating(int instr)
+int	ps_is_rotating(int instr)
 {
 	if (instr == ra || instr == rb || instr == rra || instr == rrb || instr == rr || instr == rrr)
 		return (TRUE);
diff --git a/src/tools/best_comb.c b/src/tools/best_comb.c
index d9c9064..d386efc 100644
--- a/src/tools/best_comb.c
+++ b/src/tools/best_comb.c
@@ -1,33 +1,30 @@
 /* ************************************************************************** */
 /*                                                                            */
 /*                                                        :::      ::::::::   */
-/*   can_push.c                                         :+:      :+:    :+:   */
+/*   best_comb.c                                        :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
 /*   By: nidionis <nidionis@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/02/02 23:41:34 by nidionis          #+#    #+#             */
-/*   Updated: 2025/02/03 00:10:14 by nidionis         ###   ########.fr       */
+/*   Updated: 2025/03/07 19:59:08 by nidionis         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include <push_swap.h>
 
 /**
- * @brief Trouve récursivement la meilleure combinaison d'instructions
- * 
- * Cette fonction utilise la récursion pour trouver la meilleure combinaison
- * d'instructions pour atteindre l'état souhaité
+ * @brief Trouve la meilleure combinaison d'instructions par étape
  * 
  * @param d Structure de données contenant les listes et paramètres
  * @param instr_ls Tableau d'instructions possibles
  * @param can_push Fonction qui vérifie si l'état est atteint
  * @param max_cost Coût maximum acceptable
- * @param idx Index de l'instruction dans instr_ls (pour la récursion)
+ * @param idx Index de l'instruction dans instr_ls
  * @return t_list* Liste chaînée des instructions à appliquer
  */
-static t_list *ft_best_comb_recursive(t_data *d, int *instr_ls, 
-                                    int (*can_push)(t_data *), 
-                                    int max_cost, int idx)
+static t_list *ft_best_comb_step(t_data *d, int *instr_ls, 
+                                int (*can_push)(t_data *), 
+                                int max_cost, int idx)
 {
     t_list *best_comb_in_dir;
     t_list *best_from_next;
@@ -37,7 +34,7 @@ static t_list *ft_best_comb_recursive(t_data *d, int *instr_ls,
         return (NULL);
 
     best_comb_in_dir = best_insert_dir(d, instr_ls[idx], can_push, max_cost);
-    best_from_next = ft_best_comb_recursive(d, instr_ls, can_push, max_cost, idx + 1);
+    best_from_next = ft_best_comb_step(d, instr_ls, can_push, max_cost, idx + 1);
 
     if (ft_cost(best_comb_in_dir) < ft_cost(best_from_next))
     {
@@ -58,7 +55,7 @@ static t_list *ft_best_comb_recursive(t_data *d, int *instr_ls,
 /**
  * @brief Trouve la meilleure combinaison d'instructions
  * 
- * Point d'entrée principal qui appelle la fonction récursive
+ * Point d'entrée principal qui appelle la fonction par étape
  * 
  * @param d Structure de données contenant les listes et paramètres
  * @param instr_ls Tableau d'instructions possibles
@@ -69,5 +66,5 @@ static t_list *ft_best_comb_recursive(t_data *d, int *instr_ls,
 t_list *ft_best_comb(t_data *d, int *instr_ls, int (*can_push)(t_data *), int max_cost)
 {
     d->r_instr = instr_ls;
-    return (ft_best_comb_recursive(d, instr_ls, can_push, max_cost, 0));
+    return (ft_best_comb_step(d, instr_ls, can_push, max_cost, 0));
 }
\ No newline at end of file
diff --git a/src/tools/best_insert.c b/src/tools/best_insert.c
index 4bb7211..b361d20 100644
--- a/src/tools/best_insert.c
+++ b/src/tools/best_insert.c
@@ -6,56 +6,58 @@
 /*   By: nidionis <nidionis@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/02/02 23:49:48 by nidionis          #+#    #+#             */
-/*   Updated: 2025/02/09 16:33:19 by nidionis         ###   ########.fr       */
+/*   Updated: 2025/03/07 20:06:03 by nidionis         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include <push_swap.h>
 
 /**
- * @brief Trouve récursivement la meilleure instruction dans un ensemble d'instructions
+ * @brief Trouve la meilleure instruction dans un ensemble d'instructions
  * 
- * @param d_copy Copie de la structure de données pour éviter de modifier l'originale
+ * @param d_copy Copie de la structure de données
  * @param lst_instr Tableau d'instructions possibles
  * @param can_push Fonction vérifiant si l'état est atteint
  * @param max_cost Coût maximum acceptable
- * @param idx Index courant dans le tableau d'instructions (pour la récursion)
- * @param best_instr Meilleure instruction trouvée jusque-là
- * @param best_cost Coût de la meilleure instruction trouvée jusque-là
  * @return t_instr_step* Structure contenant la meilleure instruction et son coût
  */
-static t_instr_step *find_best_instr_recursive(t_data *d_copy, int lst_instr[], 
-                                             int (*can_push)(t_data *), 
-                                             int max_cost, int idx,
-                                             int best_instr, int best_cost)
+static t_instr_step *find_best_instr(t_data *d_copy, int lst_instr[], 
+                                     int (*can_push)(t_data *), 
+                                     int max_cost)
 {
+    int idx;
     int current_cost;
+    int best_cost;
+    int best_instr;
     t_instr_step *result;
     
-    /* Cas de base : fin du tableau d'instructions */
-    if (lst_instr[idx] == LOOP_END)
-    {
-        result = malloc(sizeof(t_instr_step));
-        if (!result)
-            return (NULL);
-        result->instr = best_instr;
-        result->nb_instr = best_cost;
-        return (result);
-    }
+    idx = 0;
+    best_cost = SIZE_MAX;
+    best_instr = lst_instr[0];
     
-    /* Évaluer le coût de l'instruction courante */
-    current_cost = count_instr(d_copy, lst_instr[idx], can_push, max_cost);
-    
-    /* Si l'instruction courante est meilleure, mettre à jour les paramètres */
-    if (current_cost < best_cost)
+    /* Itérer sur toutes les instructions possibles */
+    while (lst_instr[idx] != LOOP_END)
     {
-        best_instr = lst_instr[idx];
-        best_cost = current_cost;
-        max_cost = current_cost; /* Mise à jour du coût max pour les prochaines itérations */
+        current_cost = count_instr(d_copy, lst_instr[idx], can_push, max_cost);
+        
+        /* Si l'instruction courante est meilleure, mettre à jour */
+        if (current_cost < best_cost)
+        {
+            best_instr = lst_instr[idx];
+            best_cost = current_cost;
+            max_cost = current_cost; /* Mise à jour du coût max pour les prochaines itérations */
+        }
+        
+        idx++;
     }
     
-    /* Appel récursif pour l'instruction suivante */
-    return find_best_instr_recursive(d_copy, lst_instr, can_push, max_cost, idx + 1, best_instr, best_cost);
+    /* Créer et retourner le résultat */
+    result = malloc(sizeof(t_instr_step));
+    if (!result)
+        return (NULL);
+    result->instr = best_instr;
+    result->nb_instr = best_cost;
+    return (result);
 }
 
 /**
@@ -87,8 +89,8 @@ t_list	*best_insert(t_data *d, int lst_instr[], int (*can_push)(t_data *), int m
 	}
 	else
 	{
-		/* Rechercher récursivement la meilleure instruction */
-		instr_step = find_best_instr_recursive(&d_copy, lst_instr, can_push, max_cost, 0, lst_instr[0], SIZE_MAX);
+		/* Rechercher la meilleure instruction */
+		instr_step = find_best_instr(&d_copy, lst_instr, can_push, max_cost);
 		if (!instr_step)
 			return (NULL);
 	}
@@ -140,35 +142,3 @@ t_list *init_instr_step_node(int instr, int nb_instr_init)
 	instr_step_node = ft_lstnew(instr_step);
 	return (instr_step_node);
 }
-
-
-
-
-//void	explore_insert_paths(t_data *d, int lst_instr[], int first_instr_steps[], int (*can_push)(t_data *))
-//{
-//	int	*second_instr_steps;
-//	int	j_instr = 0;
-//
-//	while (first_instr_steps[NB_INSTR]++ < ft_cost(d->best_comb))
-//	{
-//		apply_instr(d, lst_instr[j_instr], QUIET);
-//		second_instr_steps = insert_target_to_list_steps(d, lst_instr, can_push, ft_cost(d->best_comb));
-//		j_instr++;
-//	}
-//	//while (lst_instr[j_instr] != LOOP_END && first_instr_steps[NB_INSTR]++ < ft_cost(d->best_comb))
-//	//{
-//	//	apply_instr(d, lst_instr[j_instr], QUIET);
-//	//	second_instr_steps = insert_target_to_list_steps(d, lst_instr, can_push, ft_cost(d->best_comb));
-//	//	if (can_push(d))
-//	//	{
-//	//		update_best_comb(&d->best_comb, first_instr_steps, second_instr_steps);
-//	//		d->best_cost_comb = ft_cost(d->best_comb);
-//	//		free(second_instr_steps);
-//	//		break;
-//	//	}
-//	//	else
-//	//		free(second_instr_steps);
-//	//	j_instr++;
-//	//}
-//}
-//
diff --git a/src/tools/get_shortestway.c b/src/tools/get_shortestway.c
index 802cb21..947efdf 100644
--- a/src/tools/get_shortestway.c
+++ b/src/tools/get_shortestway.c
@@ -19,7 +19,7 @@ void	initialize_search(int *steps_forward, int *list_length, int *found, t_lnk *
 	*found = (list->rank == target_rank);
 }
 
-int is_rank_in_lst_forward(int target_rank, t_lnk *list)
+int ps_is_rank_in_lst_forward(int target_rank, t_lnk *list)
 {
 	int	steps_forward;
 	int	list_length;
diff --git a/src/tools/pushing_fts.c b/src/tools/pushing_fts.c
index ccf623c..47e52f7 100644
--- a/src/tools/pushing_fts.c
+++ b/src/tools/pushing_fts.c
@@ -12,12 +12,12 @@
 
 #include <push_swap.h>
 
-void	push(t_lnk **from_lst, t_lnk **to_lst)
+void	ps_push(t_lnk **from_lst, t_lnk **to_lst)
 {
-	push_item(pop_item(from_lst), to_lst);
+	ps_push_item(ps_pop_item(from_lst), to_lst);
 }
 
-void	push_item(t_lnk *lnk, t_lnk **lst)
+void	ps_push_item(t_lnk *lnk, t_lnk **lst)
 {
 	if (lnk)
 	{
@@ -36,7 +36,7 @@ void	push_item(t_lnk *lnk, t_lnk **lst)
 		printf("[push item] pushing non existing link\n");
 }
 
-t_lnk	*pop_item(t_lnk **lst)
+t_lnk	*ps_pop_item(t_lnk **lst)
 {
 	t_lnk	*poped_item;
 
@@ -54,14 +54,14 @@ t_lnk	*pop_item(t_lnk **lst)
 	return (lnk_init(poped_item));
 }
 
-void	push_a(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_push_a(t_lnk **lst_a, t_lnk **lst_b)
 {
 	if (*lst_b)
-		push(lst_b, lst_a);
+		ps_push(lst_b, lst_a);
 }
 
-void	push_b(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_push_b(t_lnk **lst_a, t_lnk **lst_b)
 {
 	if (*lst_a)
-		push(lst_a, lst_b);
+		ps_push(lst_a, lst_b);
 }
\ No newline at end of file
diff --git a/src/tools/rotate.c b/src/tools/rotate.c
index c47d712..3637c7b 100644
--- a/src/tools/rotate.c
+++ b/src/tools/rotate.c
@@ -12,7 +12,7 @@
 
 #include <push_swap.h>
 
-void	rotate_lst(t_lnk **lst)
+void	ps_rotate_lst(t_lnk **lst)
 {
 	if (*lst)
 		*lst = (*lst)->next;
@@ -20,7 +20,7 @@ void	rotate_lst(t_lnk **lst)
 		write(2, "[rotate] empty list\n", 20);
 }
 
-void	rrotate_lst(t_lnk **lst)
+void	ps_rrotate_lst(t_lnk **lst)
 {
 	if (*lst)
 		*lst = (*lst)->prev;
@@ -28,44 +28,44 @@ void	rrotate_lst(t_lnk **lst)
 		write(2, "[rotate] empty list\n", 20);
 }
 
-void	rotate_both(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_rotate_both(t_lnk **lst_a, t_lnk **lst_b)
 {
 	if (*lst_a)
-		rotate_lst(lst_a);
+		ps_rotate_lst(lst_a);
 	if (*lst_b)
-		rotate_lst(lst_b);
+		ps_rotate_lst(lst_b);
 }
 
-void	rrotate_both(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_rrotate_both(t_lnk **lst_a, t_lnk **lst_b)
 {
 	if (*lst_a)
-		rrotate_lst(lst_a);
+		ps_rrotate_lst(lst_a);
 	if (*lst_b)
-		rrotate_lst(lst_b);
+		ps_rrotate_lst(lst_b);
 }
 
-void	rotate_a(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_rotate_a(t_lnk **lst_a, t_lnk **lst_b)
 {
 	(void)lst_b;
 	if (*lst_a)
 		*lst_a = (*lst_a)->next;
 }
 
-void	rotate_b(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_rotate_b(t_lnk **lst_a, t_lnk **lst_b)
 {
 	(void)lst_a;
 	if (*lst_b)
 		*lst_b = (*lst_b)->next;
 }
 
-void	rrotate_a(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_rrotate_a(t_lnk **lst_a, t_lnk **lst_b)
 {
 	(void)lst_b;
 	if (*lst_a)
 		*lst_a = (*lst_a)->prev;
 }
 
-void	rrotate_b(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_rrotate_b(t_lnk **lst_a, t_lnk **lst_b)
 {
 	(void)lst_a;
 	if (*lst_b)
diff --git a/src/tools/swap.c b/src/tools/swap.c
index 56da126..8cfaaf8 100644
--- a/src/tools/swap.c
+++ b/src/tools/swap.c
@@ -12,7 +12,7 @@
 
 #include <push_swap.h>
 
-void	swap_lst(t_lnk **lst)
+void	ps_swap_lst(t_lnk **lst)
 {
 	t_lnk	*sec;
 
@@ -34,20 +34,20 @@ void	swap_lst(t_lnk **lst)
 	}
 }
 
-void	swap_a(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_swap_a(t_lnk **lst_a, t_lnk **lst_b)
 {
 	(void)lst_b;
-	swap_lst(lst_a);
+	ps_swap_lst(lst_a);
 }
 
-void	swap_b(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_swap_b(t_lnk **lst_a, t_lnk **lst_b)
 {
 	(void)lst_a;
-	swap_lst(lst_b);
+	ps_swap_lst(lst_b);
 }
 
-void	swap_both(t_lnk **lst_a, t_lnk **lst_b)
+void	ps_swap_both(t_lnk **lst_a, t_lnk **lst_b)
 {
-	swap_lst(lst_a);
-	swap_lst(lst_b);
+	ps_swap_lst(lst_a);
+	ps_swap_lst(lst_b);
 }
diff --git a/src/tools/verifications.c b/src/tools/verifications.c
index 4135cb6..ec0a45a 100644
--- a/src/tools/verifications.c
+++ b/src/tools/verifications.c
@@ -12,7 +12,7 @@
 
 #include <push_swap.h>
 
-int	is_sorted(t_lnk *lst)
+int	ps_is_sorted(t_lnk *lst)
 {
 	t_lnk	*lst_orig;
 
@@ -28,7 +28,7 @@ int	is_sorted(t_lnk *lst)
 	return (TRUE);
 }
 
-int	ft_no_duplicate(t_lnk *lst)
+int	ps_no_duplicate(t_lnk *lst)
 {
 	t_lnk	*lnk_ind1;
 	t_lnk	*lnk_ind2;
